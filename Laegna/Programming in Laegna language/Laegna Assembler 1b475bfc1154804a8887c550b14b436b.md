# Laegna Assembler

Assembler is subset of the language, which is identical but so small that preprocessor can utilize that.

Tens are defined by number digit indexes, which use decimals as index pointers and map into different representations; with Laegna Logecs, they could instantly become whole numbers, with mappings to their higher and lower frequencies - such as you can get rich, but in square you could get even rich compared to your first plan, rendering it to “no” in now-position parameter, which was posetion in your map. Some compilers take care of the multidimensional, first-hand apparently still containing rather logecs of working with truth values as digits, not mathematecs of doing something clever with whole numbers, which is handled rather automatically considering when the accelerations of numbers appear and your comparisons change meanings; it can be always bigger than itself, given that each time you do a cycle to get the best value, the next iteration would render it better based on your last state news.

Assembler:

- Create Tens.
- Create their two-bit representations of two Dens of O and A, for example to map R and T in different ways.
- Create free-digit systems, even where multiple digits differ.
- Create tenary tables of 16 digit matrix of 4 rows and 4 columns, with their counterpart of 4 digits on left, to be used if the two values are identical, and by changing one you would change another (primitive identity definition, use it also in Alchemy Stone).
- Create binary table of 4-digit matrix and 2-digit singularity tensor.
- Create “strings”, chains of digits - they have also potential for having additional index values, to contain U and V if they are not digit-based, but of odd number property of having 0 in the center, rather than not defining the operations - in Logecs, it’s rather hard to have digit based U without simply stating that you disallow conditionals there, where omitting the conditionals would leave a perfect zero and allow you to substract, like 1-1; still sometimes it’s rather worth some magic to handle the exceptions as such, for example by using Laegna standard coordinate - for even-number canvas of pixels indeed there is no pixel in center, but two, with perhaps a point-acceleration if it’s actually an image of Laegna Matrix, which could be.

In Assembler, user would create number and operation rules, with operations being quite trivial in Laegna, creating tenary tables worth of 2 digits and some rules to define addition and multiplication in Logecs, only by single tens, so that where the rather “invisible” (in regards to your low-level code, not in regards of the visualization rather knowing the octaves and frequencies as you request them in higher-level connections) mathematecal numbers appear in background of logec truth values, tens(, or *“ret-booleans in comparative binary scale”*), but you still work consistently with logecs in it’s one-digit simplicity or few-digit relational simplicity of discrete analysis of continuous spaces based on free variable analysis and compatible math; you don’t directly mess with large mathematecal values of micromanagement and anti-KISS, then you say you have *logex automata* behind your *logecs system* (the latter meaning high-level), doing the sub-zero manifestations invisible to you.