# Ten - the base-4 bit of Logex Automation

### Value of Ten

While a Ten contains it’s combinatoric memory for additional bits, for example in logical language it definitely needs to understand the logical constraints and it’s progress.

struct Ten {

 aggregate: actual output value, which meets the goal or gives a contradiction; this is either boolean or list of variables to be optimized to meet the condition, philosophically being open to non-related values unless they are used before reach of V (the unknown resolved by context, vs. U the unknown resolved nearby in neighbourhood or locally in the same relation space).

 o, a: boolean past condition

 u: boolean goal

 i, e: boolean future condition

}

Additionally, a list of conditions could be used to create structs of larger conditional scopes, such as arrays and dictionaries responding to metaconditions to separate their indexes in variable space.

### Context of Ten - conditionals

Ten o;

if past condition of o = cond1 { // assign cond1 to count as past condition of Ten o

// it would try two possible values of the aggregate, output, or it’s possible values, and assign the results of both conditions for o and a.

}

if future condition of o = cond2 { // assign cond2 to count as future condition of Ten o

// it would try two possible values of the aggregate, output, or it’s possible values, and assign the results of both conditions for i and e.

}

Using the input and output map, based on goal such aggregate value (the actual value of Ten vs. it’s internals / controllers is called aggregate) would be produced and mapped to aggregate that it would fit the goal, producing either true or false to both past and future.

### Growth of Ten

It would be mapped into more-dimensional space, where it exponentially grows in regards to local and global value, to be able to respond to higher complexity of the variable relations, which would interact - simpler Ten would ask for rather monolithic value. It’s true that dynamic Ten would just resolve the whole puzzle, but actually it’s better to give it progressing strength, such as the preliminary view comes from exponent factor of 1, value is filled with exponent value of 5, and when it reaches exponent value of 10 within days it would have perfectionized value and ask an user to return and clarify their goal based on it, or run automatic clarification and execution of goals. As the logecs itself is goal-based, mapping the real and projective space and thus understanding the goal-setting inside internal variables, it would feel free to refine it’s values and count for useful simplities as well as deeper digging into variable spaces for emotionally intelligent or subtle relations, blowing like wind in the I and E space (paraphrasing I Ching, to notice the relations).